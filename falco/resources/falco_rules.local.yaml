# From: https://falco.org/docs/reference/rules/default-macros/
# macro `always_true` is the flip side of the macro `never_true`but is
# commented out in the default configuration shipped with falco, as it is not
# used. Bringing it in since we want to use it below.
- macro: always_true
  condition: (evt.num>=0)

# We have a ;lot of things that are talking to apiservers, for example this
# rule reports a lot of activity from Mongo orchestrators in dev environments.
# Instead of trying to police every request and whitelist, it should be safe to
# just allow all and rely on audit logs to trace access to apiservers.
- macro: k8s_containers
  condition: (always_true)

# Patch "Packet socket created in container" rule to avoid catching metallb
# pods, which are expected to violate it.
- rule: Packet socket created in container
  desc: >
    Detect new packet socket at the device driver (OSI Layer 2) level in a container. Packet socket could be used for ARP Spoofing 
    and privilege escalation (CVE-2020-14386) by an attacker. Noise can be reduced by using the user_known_packet_socket_binaries
    template list.
  condition: > 
    evt.type=socket
    and container 
    and evt.arg.domain contains AF_PACKET 
    and not proc.name in (user_known_packet_socket_binaries)
    and not k8s.ns.name in (sys-metallb)
  output: Packet socket was created in a container | socket_info=%evt.args connection=%fd.name lport=%fd.lport rport=%fd.rport fd_type=%fd.type fd_proto=%fd.l4proto evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline terminal=%proc.tty
  priority: NOTICE
  tags:
    [maturity_stable, container, network, mitre_credential_access, T1557.002]

# Patch "Redirect STDOUT/STDIN to Network Connection in Container" rule to reduce noise
# https://github.com/falcosecurity/rules/blob/main/rules/falco_rules.yaml#L1007-L1019
# https://github.com/falcosecurity/rules/issues/131
- rule: Redirect STDOUT/STDIN to Network Connection in Container
  condition: >
    dup 
    and container 
    and evt.rawres in (0, 1, 2) 
    and fd.type in (ip_sockets) 
    and fd.types[0] in (ip_sockets) 
    and fd.types[1] in (ip_sockets) 
    and fd.types[2] in (ip_sockets) 
    and not user_known_stand_streams_redirect_activities
  override:
    condition: replace

# 
# UW Custom rules
# 


# Liveness, Readiness Probes are executed by containerd-shim
# so it sims like an container_entrypoint. following cmd can be used to get list of probes
# 
# kubectl get deployment,sts,ds --all-namespaces --output=json   | jq --raw-output '
#       .items[]
#       | .metadata.name as $name
#       | (.spec.template.spec.containers[], .spec.template.spec.initContainers[]?)
#       | (.startupProbe, .readinessProbe, .livenessProbe)
#       | .exec.command
#       | select(. != null)
#       | "\(join(" "))"
#     '
- macro: known_liveness_readiness_probes
  condition: >
    (
     proc.cmdline = "calico-node -felix-live -bird-live"
     or proc.cmdline = "calico-node -felix-ready -bird-ready"
     or proc.cmdline = "check-status -l"
     or proc.cmdline = "check-status -r"
     or proc.cmdline = "pgrep -f kafka"
     or proc.cmdline = "pgrep memcached"
     or proc.cmdline = "tridentctl -s 127.0.0.1:8000 version"
     or proc.cmdline regex "(busybox|sh -c) \/health\/redis_liveness.sh"
     or proc.cmdline regex "(busybox|sh -c) \/health\/redis_readiness.sh"
     or proc.cmdline regex "(busybox|sh -c) \/health\/sentinel_liveness.sh"
     or proc.cmdline glob "csi-node-driver --kubelet-registration-path=* --mode=kubelet-registration-probe"
     or proc.cmdline glob "sh -c while ! nc -w 1 127.0.0.1 8098; do sleep 1; done?"
    )

# modified 'Terminal shell in container' rule 
#  `proc.tty != 0`: Catches standard interactive shells where a terminal is allocated.
#   kubectl exec -it my-pod -- sh -c "ls -la"
#   kubectl exec -it my-pod -- ls -la
#   kubectl exec -it my-pod -- /bin/sh and then also capture all cmd executed in that session
# 
#  `container_entrypoint`: Catches processes spawned directly by containerd-shim
#   kubectl exec my-pod -- ls -la (without -it)
#   In this case, the 'ls' process appears as a child of the container runtime (containerd-shim)
#   This also adds little noise as we also capture all containers entry-points
# 
- rule: All Container Entrypoints and Interactive Executions
  desc: Logs all interactive sessions (TTY) and any processes executed directly by the container runtime.
  condition: >
    spawned_process
    and container
    and (proc.tty != 0 or container_entrypoint)
  output: >
    Interactive Process Started | evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname gparent=%proc.aname[2] command=%proc.cmdline terminal=%proc.tty exe_flags=%evt.arg.flags stdin_type=%proc.stdin.type stdout_type=%proc.stdout.type stderr_type=%proc.stderr.type stdin_name=%proc.stdin.name stdout_name=%proc.stdout.name stderr_name=%proc.stderr.name sname=%proc.sname sid_exe=%proc.sid.exe pid=%proc.pid gpid=%proc.pgid ppid=%proc.ppid pvpid=%proc.pvpid vpid=%proc.vpid vpgid=%proc.vpgid sid=%proc.sid
  priority: INFO
  tags: [process, mitre_execution]

- rule: All Container Entrypoints debug
  desc: Logs all interactive sessions (TTY) and any processes executed directly by the container runtime.
  condition: >
    spawned_process
    and container
    and (proc.tty != 0 or container_entrypoint)
    and proc.name in (ls, busybox, pgrep)
  output: >-
    Interactive Process Started | 
    evt_type=%evt.type
    exe=%proc.exe
    pexe=%proc.pexe
    aexe=%proc.aexe
    exepath=%proc.exepath
    pexepath=%proc.pexepath
    aexepath=%proc.aexepath
    name=%proc.name
    pname=%proc.pname
    aname=%proc.aname
    args=%proc.args
    cmdline=%proc.cmdline
    pcmdline=%proc.pcmdline
    acmdline=%proc.acmdline
    cmdnargs=%proc.cmdnargs
    cmdlenargs=%proc.cmdlenargs
    exeline=%proc.exeline
    cwd=%proc.cwd
    loginshellid=%proc.loginshellid
    tty=%proc.tty
    pid=%proc.pid
    ppid=%proc.ppid
    apid=%proc.apid
    vpid=%proc.vpid
    pvpid=%proc.pvpid
    sid=%proc.sid
    sname=%proc.sname
    sid_exe=%proc.sid.exe
    sid_exepath=%proc.sid.exepath
    vpgid=%proc.vpgid
    vpgid_name=%proc.vpgid.name
    vpgid_exe=%proc.vpgid.exe
    vpgid_exepath=%proc.vpgid.exepath
    duration=%proc.duration
    ppid_duration=%proc.ppid.duration
    pid_ts=%proc.pid.ts
    ppid_ts=%proc.ppid.ts
    is_exe_writable=%proc.is_exe_writable
    is_exe_upper_layer=%proc.is_exe_upper_layer
    is_exe_from_memfd=%proc.is_exe_from_memfd
    is_sid_leader=%proc.is_sid_leader
    is_vpgid_leader=%proc.is_vpgid_leader
    exe_ino=%proc.exe_ino
    exe_ino_ctime=%proc.exe_ino.ctime
    exe_ino_mtime=%proc.exe_ino.mtime
    exe_ino_ctime_duration_proc_start=%proc.exe_ino.ctime_duration_proc_start
    exe_ino_ctime_duration_pidns_start=%proc.exe_ino.ctime_duration_pidns_start
    pidns_init_start_ts=%proc.pidns_init_start_ts
    thread_cap_permitted=%thread.cap_permitted
    thread_cap_inheritable=%thread.cap_inheritable
    thread_cap_effective=%thread.cap_effective
    fdopencount=%proc.fdopencount
    fdlimit=%proc.fdlimit
    fdusage=%proc.fdusage
    vmsize=%proc.vmsize
    vmrss=%proc.vmrss
    vmswap=%proc.vmswap
    thread_pfmajor=%thread.pfmajor
    thread_pfminor=%thread.pfminor
    thread_tid=%thread.tid
    thread_ismain=%thread.ismain
    thread_vtid=%thread.vtid
    thread_exectime=%thread.exectime
    thread_totexectime=%thread.totexectime
    thread_cgroups=%thread.cgroups
    nthreads=%proc.nthreads
    nchilds=%proc.nchilds
    thread_cpu=%thread.cpu
    thread_cpu_user=%thread.cpu.user
    thread_cpu_system=%thread.cpu.system
    thread_vmsize=%thread.vmsize
    thread_vmrss=%thread.vmrss
    pgid_name=%proc.pgid.name
    pgid_exe=%proc.pgid.exe
    pgid_exepath=%proc.pgid.exepath
    is_exe_lower_layer=%proc.is_exe_lower_layer
    is_pgid_leader=%proc.is_pgid_leader
    stdin_type=%proc.stdin.type
    stdout_type=%proc.stdout.type
    stderr_type=%proc.stderr.type
    stdin_name=%proc.stdin.name
    stdout_name=%proc.stdout.name
    stderr_name=%proc.stderr.name
    pgid=%proc.pgid
  priority: INFO
  tags: [process, mitre_execution]

- rule: All Node Interactive Executions
  desc: Logs all interactive sessions (TTY) and any processes executed directly by the container runtime.
  condition: >
    spawned_process
    and (proc.tty != 0 or proc.aname=sshd-session)
    and not container
  output: >
    Interactive Process Started | evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname gparent=%proc.aname[2] command=%proc.cmdline terminal=%proc.tty exe_flags=%evt.arg.flags stdin_type=%proc.stdin.type stdout_type=%proc.stdout.type stderr_type=%proc.stderr.type stdin_name=%proc.stdin.name stdout_name=%proc.stdout.name stderr_name=%proc.stderr.name sname=%proc.sname sid_exe=%proc.sid.exe pid=%proc.pid gpid=%proc.pgid ppid=%proc.ppid pvpid=%proc.pvpid vpid=%proc.vpid vpgid=%proc.vpgid sid=%proc.sid
  priority: INFO
  tags: [process, mitre_execution]

